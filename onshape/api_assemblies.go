/*
 * Onshape REST API
 *
 * The Onshape REST API consumed by all clients.
 *
 * API version: 1.113
 * Contact: api-support@onshape.zendesk.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package onshape

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// AssembliesApiService AssembliesApi service
type AssembliesApiService service

type apiAddFeatureRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wvm string
	wvmid string
	eid string
	bTFeatureDefinitionCall1406 *BTFeatureDefinitionCall1406
}


func (r apiAddFeatureRequest) BTFeatureDefinitionCall1406(bTFeatureDefinitionCall1406 BTFeatureDefinitionCall1406) apiAddFeatureRequest {
	r.bTFeatureDefinitionCall1406 = &bTFeatureDefinitionCall1406
	return r
}

/*
AddFeature Method for AddFeature
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
@return apiAddFeatureRequest
*/
func (a *AssembliesApiService) AddFeature(ctx _context.Context, did string, wvm string, wvmid string, eid string) apiAddFeatureRequest {
	return apiAddFeatureRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wvm: wvm,
		wvmid: wvmid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return BTFeatureDefinitionResponse1617
*/
func (r apiAddFeatureRequest) Execute() (BTFeatureDefinitionResponse1617, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTFeatureDefinitionResponse1617
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.AddFeature")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
	
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTFeatureDefinitionCall1406
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTFeatureDefinitionResponse1617
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiCreateAssemblyRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wid string
	bTModelElementParams *BTModelElementParams
}


func (r apiCreateAssemblyRequest) BTModelElementParams(bTModelElementParams BTModelElementParams) apiCreateAssemblyRequest {
	r.bTModelElementParams = &bTModelElementParams
	return r
}

/*
CreateAssembly Create Assembly
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
@return apiCreateAssemblyRequest
*/
func (a *AssembliesApiService) CreateAssembly(ctx _context.Context, did string, wid string) apiCreateAssemblyRequest {
	return apiCreateAssemblyRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wid: wid,
	}
}

/*
Execute executes the request
 @return BTDocumentElementInfo
*/
func (r apiCreateAssemblyRequest) Execute() (BTDocumentElementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTDocumentElementInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.CreateAssembly")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/w/{wid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(r.wid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	if r.bTModelElementParams == nil {
		return localVarReturnValue, nil, reportError("bTModelElementParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTModelElementParams
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTDocumentElementInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiCreateInstanceRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wid string
	eid string
	bTAssemblyInstanceDefinitionParams *BTAssemblyInstanceDefinitionParams
}


func (r apiCreateInstanceRequest) BTAssemblyInstanceDefinitionParams(bTAssemblyInstanceDefinitionParams BTAssemblyInstanceDefinitionParams) apiCreateInstanceRequest {
	r.bTAssemblyInstanceDefinitionParams = &bTAssemblyInstanceDefinitionParams
	return r
}

/*
CreateInstance Create assembly instance
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
 * @param eid
@return apiCreateInstanceRequest
*/
func (a *AssembliesApiService) CreateInstance(ctx _context.Context, did string, wid string, eid string) apiCreateInstanceRequest {
	return apiCreateInstanceRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wid: wid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return []BTOccurrence74
*/
func (r apiCreateInstanceRequest) Execute() ([]BTOccurrence74, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BTOccurrence74
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.CreateInstance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/w/{wid}/e/{eid}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(r.wid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
	if r.bTAssemblyInstanceDefinitionParams == nil {
		return localVarReturnValue, nil, reportError("bTAssemblyInstanceDefinitionParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAssemblyInstanceDefinitionParams
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiDeleteFeatureRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wid string
	eid string
	fid string
}


/*
DeleteFeature Delete Feature
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
 * @param eid
 * @param fid
@return apiDeleteFeatureRequest
*/
func (a *AssembliesApiService) DeleteFeature(ctx _context.Context, did string, wid string, eid string, fid string) apiDeleteFeatureRequest {
	return apiDeleteFeatureRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wid: wid,
		eid: eid,
		fid: fid,
	}
}

/*
Execute executes the request
 @return BTFeatureApiBase1430
*/
func (r apiDeleteFeatureRequest) Execute() (BTFeatureApiBase1430, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTFeatureApiBase1430
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.DeleteFeature")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(r.wid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", _neturl.QueryEscape(parameterToString(r.fid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiDeleteInstanceRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	eid string
	wid string
	nid string
}


/*
DeleteInstance Delete assembly instance.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param eid
 * @param wid
 * @param nid
@return apiDeleteInstanceRequest
*/
func (a *AssembliesApiService) DeleteInstance(ctx _context.Context, did string, eid string, wid string, nid string) apiDeleteInstanceRequest {
	return apiDeleteInstanceRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		eid: eid,
		wid: wid,
		nid: nid,
	}
}

/*
Execute executes the request

*/
func (r apiDeleteInstanceRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.DeleteInstance")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/w/{wid}/e/{eid}/instance/nodeid/{nid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(r.wid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nid"+"}", _neturl.QueryEscape(parameterToString(r.nid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
type apiGetAssemblyBoundingBoxesRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wvm string
	wvmid string
	eid string
	linkDocumentId *string
	includeHidden *bool
	displayStateId *string
	configuration *string
	explodedViewId *string
}


func (r apiGetAssemblyBoundingBoxesRequest) LinkDocumentId(linkDocumentId string) apiGetAssemblyBoundingBoxesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r apiGetAssemblyBoundingBoxesRequest) IncludeHidden(includeHidden bool) apiGetAssemblyBoundingBoxesRequest {
	r.includeHidden = &includeHidden
	return r
}

func (r apiGetAssemblyBoundingBoxesRequest) DisplayStateId(displayStateId string) apiGetAssemblyBoundingBoxesRequest {
	r.displayStateId = &displayStateId
	return r
}

func (r apiGetAssemblyBoundingBoxesRequest) Configuration(configuration string) apiGetAssemblyBoundingBoxesRequest {
	r.configuration = &configuration
	return r
}

func (r apiGetAssemblyBoundingBoxesRequest) ExplodedViewId(explodedViewId string) apiGetAssemblyBoundingBoxesRequest {
	r.explodedViewId = &explodedViewId
	return r
}

/*
GetAssemblyBoundingBoxes Bounding Boxes.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
@return apiGetAssemblyBoundingBoxesRequest
*/
func (a *AssembliesApiService) GetAssemblyBoundingBoxes(ctx _context.Context, did string, wvm string, wvmid string, eid string) apiGetAssemblyBoundingBoxesRequest {
	return apiGetAssemblyBoundingBoxesRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wvm: wvm,
		wvmid: wvmid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return BTBoundingBoxInfo
*/
func (r apiGetAssemblyBoundingBoxesRequest) Execute() (BTBoundingBoxInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTBoundingBoxInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.GetAssemblyBoundingBoxes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/boundingboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
					
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.includeHidden != nil {
		localVarQueryParams.Add("includeHidden", parameterToString(*r.includeHidden, ""))
	}
	if r.displayStateId != nil {
		localVarQueryParams.Add("displayStateId", parameterToString(*r.displayStateId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetAssemblyDefinitionRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wvm string
	wvmid string
	eid string
	linkDocumentId *string
	includeMateFeatures *bool
	includeNonSolids *bool
	includeMateConnectors *bool
	configuration *string
	explodedViewId *string
}


func (r apiGetAssemblyDefinitionRequest) LinkDocumentId(linkDocumentId string) apiGetAssemblyDefinitionRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r apiGetAssemblyDefinitionRequest) IncludeMateFeatures(includeMateFeatures bool) apiGetAssemblyDefinitionRequest {
	r.includeMateFeatures = &includeMateFeatures
	return r
}

func (r apiGetAssemblyDefinitionRequest) IncludeNonSolids(includeNonSolids bool) apiGetAssemblyDefinitionRequest {
	r.includeNonSolids = &includeNonSolids
	return r
}

func (r apiGetAssemblyDefinitionRequest) IncludeMateConnectors(includeMateConnectors bool) apiGetAssemblyDefinitionRequest {
	r.includeMateConnectors = &includeMateConnectors
	return r
}

func (r apiGetAssemblyDefinitionRequest) Configuration(configuration string) apiGetAssemblyDefinitionRequest {
	r.configuration = &configuration
	return r
}

func (r apiGetAssemblyDefinitionRequest) ExplodedViewId(explodedViewId string) apiGetAssemblyDefinitionRequest {
	r.explodedViewId = &explodedViewId
	return r
}

/*
GetAssemblyDefinition Assembly Definition.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
@return apiGetAssemblyDefinitionRequest
*/
func (a *AssembliesApiService) GetAssemblyDefinition(ctx _context.Context, did string, wvm string, wvmid string, eid string) apiGetAssemblyDefinitionRequest {
	return apiGetAssemblyDefinitionRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wvm: wvm,
		wvmid: wvmid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return BTAssemblyDefinitionInfo
*/
func (r apiGetAssemblyDefinitionRequest) Execute() (BTAssemblyDefinitionInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTAssemblyDefinitionInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.GetAssemblyDefinition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
						
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.includeMateFeatures != nil {
		localVarQueryParams.Add("includeMateFeatures", parameterToString(*r.includeMateFeatures, ""))
	}
	if r.includeNonSolids != nil {
		localVarQueryParams.Add("includeNonSolids", parameterToString(*r.includeNonSolids, ""))
	}
	if r.includeMateConnectors != nil {
		localVarQueryParams.Add("includeMateConnectors", parameterToString(*r.includeMateConnectors, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTAssemblyDefinitionInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetAssemblyShadedViewsRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wvm string
	wvmid string
	eid string
	linkDocumentId *string
	viewMatrix *string
	outputHeight *int32
	outputWidth *int32
	pixelSize *float64
	edges *string
	showAllParts *bool
	includeSurfaces *bool
	useAntiAliasing *bool
	displayStateId *string
	configuration *string
	explodedViewId *string
}


func (r apiGetAssemblyShadedViewsRequest) LinkDocumentId(linkDocumentId string) apiGetAssemblyShadedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r apiGetAssemblyShadedViewsRequest) ViewMatrix(viewMatrix string) apiGetAssemblyShadedViewsRequest {
	r.viewMatrix = &viewMatrix
	return r
}

func (r apiGetAssemblyShadedViewsRequest) OutputHeight(outputHeight int32) apiGetAssemblyShadedViewsRequest {
	r.outputHeight = &outputHeight
	return r
}

func (r apiGetAssemblyShadedViewsRequest) OutputWidth(outputWidth int32) apiGetAssemblyShadedViewsRequest {
	r.outputWidth = &outputWidth
	return r
}

func (r apiGetAssemblyShadedViewsRequest) PixelSize(pixelSize float64) apiGetAssemblyShadedViewsRequest {
	r.pixelSize = &pixelSize
	return r
}

func (r apiGetAssemblyShadedViewsRequest) Edges(edges string) apiGetAssemblyShadedViewsRequest {
	r.edges = &edges
	return r
}

func (r apiGetAssemblyShadedViewsRequest) ShowAllParts(showAllParts bool) apiGetAssemblyShadedViewsRequest {
	r.showAllParts = &showAllParts
	return r
}

func (r apiGetAssemblyShadedViewsRequest) IncludeSurfaces(includeSurfaces bool) apiGetAssemblyShadedViewsRequest {
	r.includeSurfaces = &includeSurfaces
	return r
}

func (r apiGetAssemblyShadedViewsRequest) UseAntiAliasing(useAntiAliasing bool) apiGetAssemblyShadedViewsRequest {
	r.useAntiAliasing = &useAntiAliasing
	return r
}

func (r apiGetAssemblyShadedViewsRequest) DisplayStateId(displayStateId string) apiGetAssemblyShadedViewsRequest {
	r.displayStateId = &displayStateId
	return r
}

func (r apiGetAssemblyShadedViewsRequest) Configuration(configuration string) apiGetAssemblyShadedViewsRequest {
	r.configuration = &configuration
	return r
}

func (r apiGetAssemblyShadedViewsRequest) ExplodedViewId(explodedViewId string) apiGetAssemblyShadedViewsRequest {
	r.explodedViewId = &explodedViewId
	return r
}

/*
GetAssemblyShadedViews Method for GetAssemblyShadedViews
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
@return apiGetAssemblyShadedViewsRequest
*/
func (a *AssembliesApiService) GetAssemblyShadedViews(ctx _context.Context, did string, wvm string, wvmid string, eid string) apiGetAssemblyShadedViewsRequest {
	return apiGetAssemblyShadedViewsRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wvm: wvm,
		wvmid: wvmid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return BTShadedViewsInfo
*/
func (r apiGetAssemblyShadedViewsRequest) Execute() (BTShadedViewsInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTShadedViewsInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.GetAssemblyShadedViews")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/shadedviews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
												
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.viewMatrix != nil {
		localVarQueryParams.Add("viewMatrix", parameterToString(*r.viewMatrix, ""))
	}
	if r.outputHeight != nil {
		localVarQueryParams.Add("outputHeight", parameterToString(*r.outputHeight, ""))
	}
	if r.outputWidth != nil {
		localVarQueryParams.Add("outputWidth", parameterToString(*r.outputWidth, ""))
	}
	if r.pixelSize != nil {
		localVarQueryParams.Add("pixelSize", parameterToString(*r.pixelSize, ""))
	}
	if r.edges != nil {
		localVarQueryParams.Add("edges", parameterToString(*r.edges, ""))
	}
	if r.showAllParts != nil {
		localVarQueryParams.Add("showAllParts", parameterToString(*r.showAllParts, ""))
	}
	if r.includeSurfaces != nil {
		localVarQueryParams.Add("includeSurfaces", parameterToString(*r.includeSurfaces, ""))
	}
	if r.useAntiAliasing != nil {
		localVarQueryParams.Add("useAntiAliasing", parameterToString(*r.useAntiAliasing, ""))
	}
	if r.displayStateId != nil {
		localVarQueryParams.Add("displayStateId", parameterToString(*r.displayStateId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	if r.explodedViewId != nil {
		localVarQueryParams.Add("explodedViewId", parameterToString(*r.explodedViewId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTShadedViewsInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetBillOfMaterialsRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wvm string
	wvmid string
	eid string
	metadataWorkspaceId *string
	bomColumnIds *[]string
	indented *bool
	multiLevel *bool
	generateIfAbsent *bool
	linkDocumentId *string
	configuration *string
}


func (r apiGetBillOfMaterialsRequest) MetadataWorkspaceId(metadataWorkspaceId string) apiGetBillOfMaterialsRequest {
	r.metadataWorkspaceId = &metadataWorkspaceId
	return r
}

func (r apiGetBillOfMaterialsRequest) BomColumnIds(bomColumnIds []string) apiGetBillOfMaterialsRequest {
	r.bomColumnIds = &bomColumnIds
	return r
}

func (r apiGetBillOfMaterialsRequest) Indented(indented bool) apiGetBillOfMaterialsRequest {
	r.indented = &indented
	return r
}

func (r apiGetBillOfMaterialsRequest) MultiLevel(multiLevel bool) apiGetBillOfMaterialsRequest {
	r.multiLevel = &multiLevel
	return r
}

func (r apiGetBillOfMaterialsRequest) GenerateIfAbsent(generateIfAbsent bool) apiGetBillOfMaterialsRequest {
	r.generateIfAbsent = &generateIfAbsent
	return r
}

func (r apiGetBillOfMaterialsRequest) LinkDocumentId(linkDocumentId string) apiGetBillOfMaterialsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

func (r apiGetBillOfMaterialsRequest) Configuration(configuration string) apiGetBillOfMaterialsRequest {
	r.configuration = &configuration
	return r
}

/*
GetBillOfMaterials Get Bill of Materials
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
@return apiGetBillOfMaterialsRequest
*/
func (a *AssembliesApiService) GetBillOfMaterials(ctx _context.Context, did string, wvm string, wvmid string, eid string) apiGetBillOfMaterialsRequest {
	return apiGetBillOfMaterialsRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wvm: wvm,
		wvmid: wvmid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return JsonNode
*/
func (r apiGetBillOfMaterialsRequest) Execute() (JsonNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonNode
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.GetBillOfMaterials")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/bom"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
							
	if r.metadataWorkspaceId != nil {
		localVarQueryParams.Add("metadataWorkspaceId", parameterToString(*r.metadataWorkspaceId, ""))
	}
	if r.bomColumnIds != nil {
		t := *r.bomColumnIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("bomColumnIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("bomColumnIds", parameterToString(t, "multi"))
		}
	}
	if r.indented != nil {
		localVarQueryParams.Add("indented", parameterToString(*r.indented, ""))
	}
	if r.multiLevel != nil {
		localVarQueryParams.Add("multiLevel", parameterToString(*r.multiLevel, ""))
	}
	if r.generateIfAbsent != nil {
		localVarQueryParams.Add("generateIfAbsent", parameterToString(*r.generateIfAbsent, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	if r.configuration != nil {
		localVarQueryParams.Add("configuration", parameterToString(*r.configuration, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v JsonNode
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetFeatureSpecsRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wvm string
	wvmid string
	eid string
}


/*
GetFeatureSpecs Method for GetFeatureSpecs
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
@return apiGetFeatureSpecsRequest
*/
func (a *AssembliesApiService) GetFeatureSpecs(ctx _context.Context, did string, wvm string, wvmid string, eid string) apiGetFeatureSpecsRequest {
	return apiGetFeatureSpecsRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wvm: wvm,
		wvmid: wvmid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return BTFeatureSpecsResponse664
*/
func (r apiGetFeatureSpecsRequest) Execute() (BTFeatureSpecsResponse664, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTFeatureSpecsResponse664
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.GetFeatureSpecs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/featurespecs"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTFeatureSpecsResponse664
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetFeaturesRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wvm string
	wvmid string
	eid string
	featureId *[]string
	linkDocumentId *string
}


func (r apiGetFeaturesRequest) FeatureId(featureId []string) apiGetFeaturesRequest {
	r.featureId = &featureId
	return r
}

func (r apiGetFeaturesRequest) LinkDocumentId(linkDocumentId string) apiGetFeaturesRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

/*
GetFeatures Get Feature List
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wvm
 * @param wvmid
 * @param eid
@return apiGetFeaturesRequest
*/
func (a *AssembliesApiService) GetFeatures(ctx _context.Context, did string, wvm string, wvmid string, eid string) apiGetFeaturesRequest {
	return apiGetFeaturesRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wvm: wvm,
		wvmid: wvmid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return BTAssemblyFeatureListResponse1174
*/
func (r apiGetFeaturesRequest) Execute() (BTAssemblyFeatureListResponse1174, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTAssemblyFeatureListResponse1174
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.GetFeatures")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvm"+"}", _neturl.QueryEscape(parameterToString(r.wvm, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvmid"+"}", _neturl.QueryEscape(parameterToString(r.wvmid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
		
	if r.featureId != nil {
		t := *r.featureId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("featureId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("featureId", parameterToString(t, "multi"))
		}
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v2+json;charset=UTF-8;qs=0.2"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetNamedViewsRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	eid string
	skipPerspective *bool
	linkDocumentId *string
}


func (r apiGetNamedViewsRequest) SkipPerspective(skipPerspective bool) apiGetNamedViewsRequest {
	r.skipPerspective = &skipPerspective
	return r
}

func (r apiGetNamedViewsRequest) LinkDocumentId(linkDocumentId string) apiGetNamedViewsRequest {
	r.linkDocumentId = &linkDocumentId
	return r
}

/*
GetNamedViews Method for GetNamedViews
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param eid
@return apiGetNamedViewsRequest
*/
func (a *AssembliesApiService) GetNamedViews(ctx _context.Context, did string, eid string) apiGetNamedViewsRequest {
	return apiGetNamedViewsRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		eid: eid,
	}
}

/*
Execute executes the request
 @return BTNamedViewsInfo
*/
func (r apiGetNamedViewsRequest) Execute() (BTNamedViewsInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTNamedViewsInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.GetNamedViews")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/e/{eid}/namedViews"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
		
	if r.skipPerspective != nil {
		localVarQueryParams.Add("skipPerspective", parameterToString(*r.skipPerspective, ""))
	}
	if r.linkDocumentId != nil {
		localVarQueryParams.Add("linkDocumentId", parameterToString(*r.linkDocumentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTNamedViewsInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetOrCreateBillOfMaterialsElementRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wid string
	eid string
}


/*
GetOrCreateBillOfMaterialsElement Get or Create Bill of Materials Element
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
 * @param eid
@return apiGetOrCreateBillOfMaterialsElementRequest
*/
func (a *AssembliesApiService) GetOrCreateBillOfMaterialsElement(ctx _context.Context, did string, wid string, eid string) apiGetOrCreateBillOfMaterialsElementRequest {
	return apiGetOrCreateBillOfMaterialsElementRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wid: wid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return BTDocumentElementInfo
*/
func (r apiGetOrCreateBillOfMaterialsElementRequest) Execute() (BTDocumentElementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTDocumentElementInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.GetOrCreateBillOfMaterialsElement")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/w/{wid}/e/{eid}/bomelement"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(r.wid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTDocumentElementInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiGetTranslatorFormatsRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wid string
	eid string
	checkContent *bool
}


func (r apiGetTranslatorFormatsRequest) CheckContent(checkContent bool) apiGetTranslatorFormatsRequest {
	r.checkContent = &checkContent
	return r
}

/*
GetTranslatorFormats Get Translation Formats
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
 * @param eid
@return apiGetTranslatorFormatsRequest
*/
func (a *AssembliesApiService) GetTranslatorFormats(ctx _context.Context, did string, wid string, eid string) apiGetTranslatorFormatsRequest {
	return apiGetTranslatorFormatsRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wid: wid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return []BTModelFormatInfo
*/
func (r apiGetTranslatorFormatsRequest) Execute() ([]BTModelFormatInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BTModelFormatInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.GetTranslatorFormats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/w/{wid}/e/{eid}/translationformats"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(r.wid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
	if r.checkContent != nil {
		localVarQueryParams.Add("checkContent", parameterToString(*r.checkContent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v []BTModelFormatInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiInsertTransformedInstancesRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	eid string
	wid string
	bTAssemblyTransformedInstancesDefinitionParams *BTAssemblyTransformedInstancesDefinitionParams
}


func (r apiInsertTransformedInstancesRequest) BTAssemblyTransformedInstancesDefinitionParams(bTAssemblyTransformedInstancesDefinitionParams BTAssemblyTransformedInstancesDefinitionParams) apiInsertTransformedInstancesRequest {
	r.bTAssemblyTransformedInstancesDefinitionParams = &bTAssemblyTransformedInstancesDefinitionParams
	return r
}

/*
InsertTransformedInstances Create and transform assembly instances
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param eid
 * @param wid
@return apiInsertTransformedInstancesRequest
*/
func (a *AssembliesApiService) InsertTransformedInstances(ctx _context.Context, did string, eid string, wid string) apiInsertTransformedInstancesRequest {
	return apiInsertTransformedInstancesRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		eid: eid,
		wid: wid,
	}
}

/*
Execute executes the request
 @return BTAssemblyInsertTransformedInstancesResponse
*/
func (r apiInsertTransformedInstancesRequest) Execute() (BTAssemblyInsertTransformedInstancesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTAssemblyInsertTransformedInstancesResponse
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.InsertTransformedInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/w/{wid}/e/{eid}/transformedinstances"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(r.wid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
	if r.bTAssemblyTransformedInstancesDefinitionParams == nil {
		return localVarReturnValue, nil, reportError("bTAssemblyTransformedInstancesDefinitionParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAssemblyTransformedInstancesDefinitionParams
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTAssemblyInsertTransformedInstancesResponse
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiTransformOccurrencesRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	eid string
	wid string
	bTAssemblyTransformDefinitionParams *BTAssemblyTransformDefinitionParams
}


func (r apiTransformOccurrencesRequest) BTAssemblyTransformDefinitionParams(bTAssemblyTransformDefinitionParams BTAssemblyTransformDefinitionParams) apiTransformOccurrencesRequest {
	r.bTAssemblyTransformDefinitionParams = &bTAssemblyTransformDefinitionParams
	return r
}

/*
TransformOccurrences Transform assembly occurrences.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param eid
 * @param wid
@return apiTransformOccurrencesRequest
*/
func (a *AssembliesApiService) TransformOccurrences(ctx _context.Context, did string, eid string, wid string) apiTransformOccurrencesRequest {
	return apiTransformOccurrencesRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		eid: eid,
		wid: wid,
	}
}

/*
Execute executes the request

*/
func (r apiTransformOccurrencesRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.TransformOccurrences")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/w/{wid}/e/{eid}/occurrencetransforms"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(r.wid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
	if r.bTAssemblyTransformDefinitionParams == nil {
		return nil, reportError("bTAssemblyTransformDefinitionParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTAssemblyTransformDefinitionParams
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
type apiTranslateFormatRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wv string
	wvid string
	eid string
	bTTranslateFormatParams *BTTranslateFormatParams
}


func (r apiTranslateFormatRequest) BTTranslateFormatParams(bTTranslateFormatParams BTTranslateFormatParams) apiTranslateFormatRequest {
	r.bTTranslateFormatParams = &bTTranslateFormatParams
	return r
}

/*
TranslateFormat Create Assembly translation.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wv
 * @param wvid
 * @param eid
@return apiTranslateFormatRequest
*/
func (a *AssembliesApiService) TranslateFormat(ctx _context.Context, did string, wv string, wvid string, eid string) apiTranslateFormatRequest {
	return apiTranslateFormatRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wv: wv,
		wvid: wvid,
		eid: eid,
	}
}

/*
Execute executes the request
 @return BTTranslationRequestInfo
*/
func (r apiTranslateFormatRequest) Execute() (BTTranslationRequestInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTTranslationRequestInfo
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.TranslateFormat")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/{wv}/{wvid}/e/{eid}/translations"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wv"+"}", _neturl.QueryEscape(parameterToString(r.wv, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wvid"+"}", _neturl.QueryEscape(parameterToString(r.wvid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
	
	if r.bTTranslateFormatParams == nil {
		return localVarReturnValue, nil, reportError("bTTranslateFormatParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bTTranslateFormatParams
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTTranslationRequestInfo
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type apiUpdateFeatureRequest struct {
	ctx _context.Context
	apiService *AssembliesApiService
	did string
	wid string
	eid string
	fid string
	body *string
}


func (r apiUpdateFeatureRequest) Body(body string) apiUpdateFeatureRequest {
	r.body = &body
	return r
}

/*
UpdateFeature Method for UpdateFeature
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param did
 * @param wid
 * @param eid
 * @param fid
@return apiUpdateFeatureRequest
*/
func (a *AssembliesApiService) UpdateFeature(ctx _context.Context, did string, wid string, eid string, fid string) apiUpdateFeatureRequest {
	return apiUpdateFeatureRequest{
		apiService: a,
		ctx: ctx,
		did: did,
		wid: wid,
		eid: eid,
		fid: fid,
	}
}

/*
Execute executes the request
 @return BTFeatureDefinitionResponse1617
*/
func (r apiUpdateFeatureRequest) Execute() (BTFeatureDefinitionResponse1617, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BTFeatureDefinitionResponse1617
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "AssembliesApiService.UpdateFeature")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/assemblies/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}"
	localVarPath = strings.Replace(localVarPath, "{"+"did"+"}", _neturl.QueryEscape(parameterToString(r.did, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"wid"+"}", _neturl.QueryEscape(parameterToString(r.wid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eid"+"}", _neturl.QueryEscape(parameterToString(r.eid, "")) , -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fid"+"}", _neturl.QueryEscape(parameterToString(r.fid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	
	
	
	
	
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=UTF-8; qs=0.09"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.onshape.v1+json;charset=UTF-8;qs=0.1"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BTFeatureDefinitionResponse1617
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
